{% extends 'layout/sabase.html' %}
{% load duration_filters %}

{% block content %}
<div class="container-fluid" style="height: 100vh; overflow: hidden;">
    <div class="row" style="height: 10%;">
        <div class="col-12 text-center">
            <h2 class="countdown-timer" id="roundCountdown" data-remaining="{{ round|duration_difference_seconds|default:"0" }}" data-is-paused="{{ round|round_is_paused }}">Time remaining: <span id="countdownDisplay">--:--:--</span></h2>
        </div>
    </div>
    <div class="row" style="height: 100%;">
        <div class="col-md-8" style="height: 100%;">
            <div class="card" style="height: 100%; background-color: transparent;">
                <div class="card-body d-flex flex-column" style="height: 100%;">
                    <!-- Top half (20% height) -->
                    <div class="d-flex w-100" style="height: 20%;">
                        <!-- Pre Race Check Button (50% of original width, 50% of original height) -->
                        <div style="width: 50%;" class="p-2 d-flex align-items-center">
                            <button class="btn btn-warning btn-lg" id="raceButton" style="width: 50%; height: 50%; font-size: 1.5rem; color: black;">Pre Race Check</button>
                        </div>

                        <!-- Empty Teams List (remaining width) -->
                        <div style="width: 50%;" class="p-2" id="teamsListContainer">
                            <div class="card h-100" id="emptyTeamsCard">
                                <div class="card-header d-flex justify-content-between align-items-center">
                                    <h5 class="mb-0">Teams with No Members</h5>
                                    <button class="btn btn-danger" id="deleteEmptyTeamsBtn">Delete All</button>
                                </div>
                                <div class="card-body overflow-auto" id="emptyTeamsList">
                                    <div class="text-center text-muted" id="emptyTeamsPlaceholder">
                                        Loading teams from active round...
                                    </div>
                                    <ul class="list-group" id="emptyTeamsUL">
                                        <!-- Teams will be added here -->
                                    </ul>
                                </div>
                            </div>

                            <!-- Team Select styled like Empty Teams (initially hidden) -->
                            <div class="card h-100" id="teamSelectCard" style="display: none;">
                                <div class="card-header">
                                    <h5 class="mb-0">Teams</h5>
                                </div>
                                <div class="card-body overflow-auto">
                                    <select class="form-select mb-2" id="teamSelect" style="font-size: 1.2rem;">
                                        {% for team in round.round_team_set.all %}
                                            <option value="{{ team.id }}">{{ team.team.number }} {{ team.team.team.name }}</option>
                                        {% endfor %}
                                    </select>
                                    <button class="btn btn-success w-100" id="stopGoButton">Stop&Go</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Bottom half for messages (80% height) -->
                    <div class="w-100 p-2" style="height: 80%;">
                        <div class="card h-100">
                            <div class="card-header">
                                <h5 class="mb-0">System Messages</h5>
                            </div>
                            <div class="card-body overflow-auto" id="messagesContainer">
                                <!-- Django messages will be displayed here -->
                                {% if messages %}
                                    {% for message in messages %}
                                        <div class="alert alert-{{ message.tags }}">
                                            {{ message }}
                                        </div>
                                    {% endfor %}
                                {% endif %}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-4 d-flex flex-column" style="height: 100%;">
            {% for lane in lanes %}
                <div id="lane-{{ lane.id }}" class="card mb-2" style="flex-grow: 1; background-color: transparent;">Lane {{ lane.lane }}</div>
            {% endfor %}
            <div id="changequeue" class="card mb-2" style="flex-grow: 1; background-color: transparent;">Queue</div>
        </div>
    </div>
</div>
{% endblock content %}

{% block extra_js %}
<script>
$(document).ready(function() {
    function updateCountdown() {
        const countdownEl = $('#roundCountdown');
        const displayEl = $('#countdownDisplay');
        const remainingSeconds = parseInt(countdownEl.attr('data-remaining'), 10);
        const isPaused = countdownEl.attr('data-is-paused') === 'true';

        if (isNaN(remainingSeconds)) {
            displayEl.text('--:--:--');
            return;
        }

        let remainingTime = remainingSeconds * 1000;
        if (!isPaused) {
            const now = new Date().getTime();
            const elapsedSincePageLoad = now - pageLoadTime;
            remainingTime = Math.max(0, remainingTime - elapsedSincePageLoad);
        }

        const hours = Math.floor(remainingTime / (1000 * 60 * 60));
        const minutes = Math.floor((remainingTime % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((remainingTime % (1000 * 60)) / 1000);

        displayEl.text(
            hours.toString().padStart(2, '0') + ':' +
            minutes.toString().padStart(2, '0') + ':' +
            seconds.toString().padStart(2, '0')
        );
    };

    const pageLoadTime = new Date().getTime();
    setInterval(updateCountdown, 1000);
    updateCountdown();

    // Create WebSocket connection with reconnection logic
    function createWebSocketWithReconnect(url, messageHandler, openHandler, errorHandler) {
        let socket;
        let reconnectTimeout;
        const RECONNECT_DELAY = 10000; // 10 seconds

        function connect() {
            socket = new WebSocket(url);

            socket.onmessage = messageHandler;

            socket.onopen = function(event) {
                // Clear any pending reconnect timeouts
                if (reconnectTimeout) {
                    clearTimeout(reconnectTimeout);
                    reconnectTimeout = null;
                }

                // Call the custom open handler if provided
                if (openHandler) {
                    openHandler(event);
                }
            };

            socket.onerror = function(event) {
                // Call the custom error handler if provided
                if (errorHandler) {
                    errorHandler(event);
                }
            };

            socket.onclose = function(event) {
                // Don't reconnect if the closure was clean (intentional)
                if (!event.wasClean) {
                    console.log(`WebSocket connection to ${url} closed unexpectedly. Reconnecting in 10 seconds...`);

                    // Schedule reconnection
                    reconnectTimeout = setTimeout(function() {
                        console.log(`Attempting to reconnect to ${url}...`);
                        connect();
                    }, RECONNECT_DELAY);
                }
            };
        }

        // Initial connection
        connect();

        // Return functions to interact with the socket
        return {
            send: function(data) {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(data);
                } else {
                    console.warn("Cannot send message, socket is not open");
                }
            },
            close: function() {
                if (socket) {
                    // Clear reconnect timeout to prevent reconnection after manual close
                    if (reconnectTimeout) {
                        clearTimeout(reconnectTimeout);
                        reconnectTimeout = null;
                    }
                    socket.close();
                }
            }
        };
    }

    // Round socket with reconnection
    const roundSocket = createWebSocketWithReconnect(
        'ws://' + window.location.host + '/ws/roundpause/{{ round.id }}/',
        function(e) {
            const data = JSON.parse(e.data);
            if (data.type === 'round_update') {
                $('#roundCountdown').data('is-paused', data.is_paused);
                if (data.remaining_seconds !== undefined) {
                    $('#roundCountdown').attr('data-remaining', data.remaining_seconds);
                }
                window.pageLoadTime = new Date().getTime();
            }
        }
    );

    // Lane sockets with reconnection
    {% for lane in lanes %}
    const laneNumber{{ lane.id }} = {{ lane.lane }};

    const socketcl{{ lane.id }} = createWebSocketWithReconnect(
        `ws://${window.location.host}/ws/pitlanes/${laneNumber{{ lane.id }}}/`,
        function(event) {
            const data = JSON.parse(event.data);
            if (data.type === 'rclane.update') {
                document.getElementById(`lane-{{ lane.id }}`).outerHTML = data.lane_html;
            }
        }
    );

    function loadLane{{ lane.id }}() {
        $.get('/pitlanedetail/{{ lane.lane }}/', function(data) {
            document.getElementById(`lane-{{ lane.id }}`).outerHTML = data;
        });
    }
    loadLane{{ lane.id }}(); // Load on page load
    {% endfor %}

    // Button event handlers
    $('#raceButton').click(function() {
        const button = $(this);
        $.ajaxSetup({
            headers: { "X-CSRFToken": getCookie("csrftoken") }
        });

        if (button.text() === 'Pre Race Check') {
            $.post('/preracecheck/', function(response) {
                if (response.result) {
                    button.removeClass('btn-warning').addClass('btn-success').text('Start').css('color', 'white');
                    // Show teamSelect in place of emptyTeams
                    $('#emptyTeamsCard').hide();
                    $('#teamSelectCard').show();
                } else {
                    for (const item of response.error) {
                        addSystemMessage(item,"warning");
                    }
                }
            });
        } else if (button.text() === 'Start') {
            $.post('/race/start/', function() {
                button.removeClass('btn-success').addClass('btn-danger').text('False Start').css('color', 'white');
                setTimeout(function() {
                    if (button.text() === 'False Start') {
                        button.removeClass('btn-danger').addClass('btn-warning').text('Pause').css('color', 'black');
                    }
                }, 15000);
            });
        } else if (button.text() === 'False Start') {
            $.post('/falsestart/', function() {
                button.removeClass('btn-danger').addClass('btn-success').text('Start').css('color', 'white');
            });
        } else if (button.text() === 'Pause') {
            $.post('/racepaused/', function() {
                button.removeClass('btn-warning').addClass('btn-success').text('Restart').css('color', 'white');
            });
        } else if (button.text() === 'Restart') {
            $.post('/racerestart/', function() {
                button.removeClass('btn-success').addClass('btn-danger').text('False Restart').css('color', 'white');
                setTimeout(function() {
                    if (button.text() === 'False Restart') {
                        button.removeClass('btn-danger').addClass('btn-success').text('Restart').css('color', 'white');
                    }
                }, 15000);
            });
        } else if (button.text() === 'False Restart') {
            $.post('/falserestart/', function() {
                button.removeClass('btn-danger').addClass('btn-success').text('Restart').css('color', 'white');
            });
        } else if (button.text() === 'End Race') {
          $.post('/endofrace/', function() {
            button.prop('disabled', true);
          });
        }

        const remainingSeconds = parseInt($('#roundCountdown').attr('data-remaining'), 10);
        if (remainingSeconds < 120) {
          button.removeClass('btn-warning').removeClass('btn-success').addClass('btn-danger').text('End Race').css('color', 'white');
        }
    });

    $('#stopGoButton').click(function() {
        const teamId = $('#teamSelect').val();
        const button = $(this);
        const card = button.closest('.card');

        if (button.text() === 'Stop&Go') {
            $.post('/serve_team/', { team_id: teamId }, function() {
                card.css('background-color', 'red');
                button.text('Served');
            });
        } else {
            card.css('background-color', 'transparent');
            button.text('Stop&Go');
            $('#teamSelect').val($('#teamSelect option:first').val());
        }
    });
});

// Initialize empty teams WebSocket connection with reconnection
document.addEventListener('DOMContentLoaded', function() {
    // Create WebSocket connection with reconnection logic
    function createWebSocketWithReconnect(url, messageHandler, openHandler, errorHandler) {
        let socket;
        let reconnectTimeout;
        const RECONNECT_DELAY = 10000; // 10 seconds

        function connect() {
            socket = new WebSocket(url);

            socket.onmessage = messageHandler;

            socket.onopen = function(event) {
                // Clear any pending reconnect timeouts
                if (reconnectTimeout) {
                    clearTimeout(reconnectTimeout);
                    reconnectTimeout = null;
                }

                // Call the custom open handler if provided
                if (openHandler) {
                    openHandler(event);
                }
            };

            socket.onerror = function(event) {
                // Call the custom error handler if provided
                if (errorHandler) {
                    errorHandler(event);
                }
            };

            socket.onclose = function(event) {
                // Don't reconnect if the closure was clean (intentional)
                if (!event.wasClean) {
                    console.log(`WebSocket connection to ${url} closed unexpectedly. Reconnecting in 10 seconds...`);

                    // Schedule reconnection
                    reconnectTimeout = setTimeout(function() {
                        console.log(`Attempting to reconnect to ${url}...`);
                        connect();
                    }, RECONNECT_DELAY);
                }
            };
        }

        // Initial connection
        connect();

        // Return functions to interact with the socket
        return {
            send: function(data) {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(data);
                } else {
                    console.warn("Cannot send message, socket is not open");
                }
            },
            close: function() {
                if (socket) {
                    // Clear reconnect timeout to prevent reconnection after manual close
                    if (reconnectTimeout) {
                        clearTimeout(reconnectTimeout);
                        reconnectTimeout = null;
                    }
                    socket.close();
                }
            }
        };
    }

    const emptyTeamsSocket = createWebSocketWithReconnect(
        'ws://' + window.location.host + '/ws/empty_teams/',
        function(e) {
            const data = JSON.parse(e.data);
            if (data.type === 'empty_teams_list') {
                updateEmptyTeamsList(data.teams);
            } else if (data.type === 'system_message') {
                addSystemMessage(data.message, data.tag);
            }
        },
        function(e) {
            console.log('WebSocket connection established');
            document.getElementById('emptyTeamsPlaceholder').textContent = 'Waiting for data...';
        },
        function(e) {
            console.error('WebSocket error:', e);
            document.getElementById('emptyTeamsPlaceholder').textContent = 'Connection error!';
        }
    );

    // Set up delete button
    document.getElementById('deleteEmptyTeamsBtn').addEventListener('click', function() {
        if (confirm('Are you sure you want to delete all teams with no members?')) {
            emptyTeamsSocket.send(JSON.stringify({
                'action': 'delete_empty_teams'
            }));
        }
    });

    // For individual team deletion buttons
    document.querySelectorAll('.delete-single-team').forEach(button => {
        button.addEventListener('click', function() {
            const teamId = this.getAttribute('data-team-id');
            if (confirm('Delete this team?')) {
                emptyTeamsSocket.send(JSON.stringify({
                    'action': 'delete_single_team',
                    'team_id': teamId
                }));
            }
        });
    });
});

// Function to update the empty teams list
function updateEmptyTeamsList(teams) {
    const emptyTeamsUL = document.getElementById('emptyTeamsUL');
    const placeholder = document.getElementById('emptyTeamsPlaceholder');

    // Clear current list
    emptyTeamsUL.innerHTML = '';

    if (teams.length === 0) {
        placeholder.textContent = 'No empty teams found';
        placeholder.style.display = 'block';
        emptyTeamsUL.style.display = 'none';
    } else {
        placeholder.style.display = 'none';
        emptyTeamsUL.style.display = 'block';

        // Add each team to the list
        teams.forEach(function(team) {
            const li = document.createElement('li');
            li.className = 'list-group-item d-flex justify-content-between align-items-center';

            // Format: Team name (Number) - Championship name
            li.innerHTML = `
                <span>${team.team_name} (#${team.number}) - ${team.championship_name}</span>
                <button class="btn btn-sm btn-outline-danger delete-single-team"
                        data-team-id="${team.id}">Delete</button>
            `;

            emptyTeamsUL.appendChild(li);
        });

        // Add event listeners for individual team deletion
        document.querySelectorAll('.delete-single-team').forEach(button => {
            button.addEventListener('click', function() {
                const teamId = this.getAttribute('data-team-id');
                if (confirm('Delete this team?')) {
                    const emptyTeamsSocket = new WebSocket(
                        'ws://' + window.location.host + '/ws/empty_teams/'
                    );

                    emptyTeamsSocket.onopen = function() {
                        emptyTeamsSocket.send(JSON.stringify({
                            'action': 'delete_single_team',
                            'team_id': teamId
                        }));
                    };
                }
            });
        });
    }
}

// Function to add a system message
function addSystemMessage(message, tag) {
    const messagesContainer = document.getElementById('messagesContainer');

    const alertDiv = document.createElement('div');
    alertDiv.className = `alert alert-${tag}`;
    alertDiv.textContent = message;

    // Add message to the top of the container
    messagesContainer.insertBefore(alertDiv, messagesContainer.firstChild);

    // Optional: Auto-dismiss after some time
    setTimeout(function() {
        alertDiv.style.opacity = '0';
        setTimeout(function() {
            alertDiv.remove();
        }, 1000);
    }, 10000);
}

// Function to get CSRF token for AJAX requests
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}
</script>
{% endblock extra_js %}
