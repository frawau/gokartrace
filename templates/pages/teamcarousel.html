{% extends "layout/fscontent.html" %}
{% load timer_tags %}

{% block extra_style %}
@media (max-width: 768px) {
    .card-title {
        font-size: 2.5rem !important;
    }
    table {
        font-size: 2rem !important;
    }
    th, td {
        padding: 8px !important;
        border: 6px solid #ddd !important;
    }
    table thead tr th:nth-child(3),
    table tbody tr td:nth-child(3) {
        display: none;
    }
    table tbody tr td:nth-child(2) {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    table tbody tr td:nth-child(2)::after{
        content: attr(data-current-session);
    }
}
{% endblock extra_style %}

{% block main_content %}
<div class="container-fluid">
    {% if round is None %}
        <h2>Hu?</h2>
        <div id="teamCarousel" class="carousel slide" data-ride="carousel">
            <div class="carousel-inner">
                <div class="carousel-item active">
                    <div class="card" style="background-color: transparent;">
                        <div class="card-body">
                            <h1>No race today</h1>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    {% else %}
        <div class="row mb-4">
            <div class="col-12 text-left">
                <h1>{{ round.name }}&nbsp;&nbsp;Remaining Time: {% timer_widget "race-countdown" "countdownDisplay" round %}</h1>
            </div>
        </div>

        <div id="teamCarousel" class="carousel slide" data-bs-ride="carousel" data-bs-interval="10000">
            <div class="carousel-inner">
                {% for round_team in round.round_team_set.all %}
                    <div class="carousel-item {% if forloop.first %}active{% endif %}" id="team-slide-{{ round_team.id }}">
                        {% include "layout/teamcard.html" with round_team=round_team %}
                    </div>
                {% endfor %}
            </div>

            <button class="carousel-control-prev" type="button" data-bs-target="#teamCarousel" data-bs-slide="prev">
                <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                <span class="visually-hidden">Previous</span>
            </button>
            <button class="carousel-control-next" type="button" data-bs-target="#teamCarousel" data-bs-slide="next">
                <span class="carousel-control-next-icon" aria-hidden="true"></span>
                <span class="visually-hidden">Next</span>
            </button>
        </div>
    {% endif %}
</div>
{% endblock main_content %}

{% block extra_js %}
{% if round is not None %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Initialize Bootstrap Carousel
    const carousel = document.getElementById('teamCarousel');
    if (carousel) {
        // Check if we're using Bootstrap 5
        if (typeof bootstrap !== 'undefined') {
            // Bootstrap 5
            const carouselInstance = new bootstrap.Carousel(carousel, {
                interval: 5000, // 5 seconds between slides
                wrap: true,     // Cycle continuously
                pause: false    // Don't pause on hover
            });
        } else {
            // Bootstrap 4 (fallback)
            $(carousel).carousel({
                interval: 5000,
                wrap: true,
                pause: false
            });
        }
    }

    // Connect to WebSocket for round updates
    const roundId = {{ round.id }};
    let socket = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 50;
    const reconnectDelay = 3000;

    function connectWebSocket() {
        const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const wsPath = `${wsScheme}://${window.location.host}/ws/round/${roundId}/`;

        if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
            socket.close();
        }

        socket = new WebSocket(wsPath);

        socket.onopen = function() {
            console.log('WebSocket connection established');
            reconnectAttempts = 0;
        };

        socket.onmessage = function(event) {
            const data = JSON.parse(event.data);
            console.log("WebSocket received:", data); // Add logging

            if (data.type === 'round_update') {
                const isPaused = data.is_paused; // Get pause state first

                // 1. Handle countdown timer updates (if present)
                if (data.remaining_seconds !== undefined && data.remaining_seconds !== null) {
                    timerRegistry.countdownTimers.forEach(timer => {
                        // Ensure countdown is also paused/resumed correctly based on round state
                        timer.updateRemainingTime(data.remaining_seconds);
                        timer.updatePauseState(isPaused); // Apply pause state here too
                    });
                }

                // 2. Update pause state for ALL relevant round timers (including driver total/session)
                // This ensures timers pause/resume with the overall race state.
                if (timerRegistry.byRoundId[roundId]) {
                    timerRegistry.byRoundId[roundId].forEach(timer => {
                         // Don't pause/resume countdown timers here again if handled above
                        if (timer.countDirection !== 'down') {
                            timer.updatePauseState(isPaused);
                        }
                    });
                }

                // 3. Handle SPECIFIC driver session activation/deactivation
                if (data.session_update && data.driver_id) {
                    console.log(`Handling session update for driver ${data.driver_id}, active: ${data.driver_active}`);
                    const driverTimers = timerRegistry.byDriverId[data.driver_id];
                    const newOntrack = data.driver_active; // True if driver is now active, false otherwise

                    // --- REMOVED HTML FETCHING AND REFRESH EVENT ---

                    // Update the data attribute for styling if needed
                    const driverRow = document.getElementById(`driver-row-${data.driver_id}`);
                    if (driverRow) {
                        driverRow.setAttribute('data-ontrack', newOntrack ? 'true' : 'false');
                        // You might want to add/remove CSS classes here instead of direct style manipulation
                        // e.g., driverRow.classList.toggle('driver-active', newOntrack);
                    }

                     // Visually manage the session cell container if needed (optional)
                     const sessionCell = document.getElementById(`session-cell-${data.driver_id}`);
                     if (sessionCell) {
                         // Example: Hide/show the cell content area or apply a class
                          const timerSpan = sessionCell.querySelector('[data-timer]'); // Find the timer span within
                          if(timerSpan){
                              timerSpan.style.visibility = newOntrack ? 'visible' : 'hidden';
                              // OR: sessionCell.classList.toggle('session-inactive', !newOntrack);
                          } else if (newOntrack) {
                              // This case *shouldn't* happen if the template always renders it,
                              // but indicates a potential issue if the span isn't found when it should be active.
                              console.warn(`Session timer span not found in cell session-cell-${data.driver_id} when activating.`);
                          }
                     }


                    // Update the ACTUAL TimerWidget instances
                    if (driverTimers) {
                        driverTimers.forEach(timer => {
                            console.log(`Updating timer ${timer.element.id} (type: ${timer.timerType}) for driver ${data.driver_id}`);
                            timer.handleSessionUpdate(newOntrack);
                        });
                    } else {
                         console.warn(`No timers found in registry for driver ${data.driver_id}`);
                    }
                }
            }
        };

        socket.onclose = function(event) {
            if (event.wasClean) {
                console.log(`WebSocket connection closed cleanly, code=${event.code}, reason=${event.reason}`);
                return;
            }
            console.warn('WebSocket connection lost, attempting to reconnect...');
            if (reconnectAttempts < maxReconnectAttempts) {
                const delay = Math.min(reconnectDelay * Math.pow(1.5, reconnectAttempts), 30000);
                reconnectAttempts++;
                console.log(`Reconnecting in ${delay/1000} seconds... (attempt ${reconnectAttempts}/${maxReconnectAttempts})`);
                setTimeout(connectWebSocket, delay);
            } else {
                console.error('Maximum reconnection attempts reached. Please refresh the page.');
            }
        };

        socket.onerror = function(error) {
            console.error('WebSocket error:', error);
            // Attempt to reconnect on error as well
             if (socket.readyState === WebSocket.CLOSED && !event.wasClean) { // Check if it closed unexpectedly
                 console.warn('WebSocket error led to closure, attempting to reconnect...');
                  if (reconnectAttempts < maxReconnectAttempts) {
                    const delay = Math.min(reconnectDelay * Math.pow(1.5, reconnectAttempts), 30000);
                    reconnectAttempts++;
                     console.log(`Reconnecting in ${delay/1000} seconds... (attempt ${reconnectAttempts}/${maxReconnectAttempts})`);
                    setTimeout(connectWebSocket, delay);
                } else {
                    console.error('Maximum reconnection attempts reached after error. Please refresh the page.');
                }
             }
        };
    }

    // Initial connection
    connectWebSocket();
});
</script>
{% endif %}
{% endblock extra_js %}
